import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:dust_count/shared/models/task_log.dart';
import 'package:dust_count/shared/models/filter_period.dart';
import 'package:dust_count/core/constants/app_constants.dart';
import 'package:dust_count/core/extensions/date_extensions.dart';
import 'package:dust_count/core/utils/firestore_retry.dart';
import 'package:dust_count/features/tasks/data/task_repository.dart';
import 'package:dust_count/features/auth/domain/auth_providers.dart';
import 'package:dust_count/features/household/domain/household_providers.dart';

/// Task filter state
class TaskFilter {
  final DateTime? startDate;
  final DateTime? endDate;
  final String? categoryId;
  final FilterPeriod period;
  final String? performedBy;
  final String? taskNameFr;
  final TaskDifficulty? difficulty;

  const TaskFilter({
    this.startDate,
    this.endDate,
    this.categoryId,
    this.period = FilterPeriod.thisWeek,
    this.performedBy,
    this.taskNameFr,
    this.difficulty,
  });

  TaskFilter copyWith({
    DateTime? startDate,
    DateTime? endDate,
    String? categoryId,
    FilterPeriod? period,
    String? performedBy,
    String? taskNameFr,
    TaskDifficulty? difficulty,
    bool clearCategory = false,
    bool clearDates = false,
    bool clearPerformedBy = false,
    bool clearTaskNameFr = false,
    bool clearDifficulty = false,
  }) {
    return TaskFilter(
      startDate: clearDates ? null : (startDate ?? this.startDate),
      endDate: clearDates ? null : (endDate ?? this.endDate),
      categoryId: clearCategory ? null : (categoryId ?? this.categoryId),
      period: period ?? this.period,
      performedBy: clearPerformedBy ? null : (performedBy ?? this.performedBy),
      taskNameFr: clearTaskNameFr ? null : (taskNameFr ?? this.taskNameFr),
      difficulty: clearDifficulty ? null : (difficulty ?? this.difficulty),
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TaskFilter &&
          runtimeType == other.runtimeType &&
          startDate == other.startDate &&
          endDate == other.endDate &&
          categoryId == other.categoryId &&
          period == other.period &&
          performedBy == other.performedBy &&
          taskNameFr == other.taskNameFr &&
          difficulty == other.difficulty;

  @override
  int get hashCode =>
      Object.hash(startDate, endDate, categoryId, period, performedBy, taskNameFr, difficulty);
}

/// Provider for task filter state
final taskFilterProvider = StateProvider<TaskFilter>((ref) {
  final now = DateTime.now();
  return TaskFilter(
    startDate: now.startOfWeek,
    endDate: now.endOfWeek,
    period: FilterPeriod.thisWeek,
  );
});

/// Provider for filtered task logs stream.
///
/// Includes a retry mechanism for permission-denied errors that can occur
/// right after joining a household (Firestore security rule race condition).
final filteredTaskLogsProvider = StreamProvider<List<TaskLog>>((ref) {
  final householdId = ref.watch(currentHouseholdIdProvider);

  if (householdId == null) {
    return Stream.value([]);
  }

  final filter = ref.watch(taskFilterProvider);
  final taskRepository = ref.watch(taskRepositoryProvider);

  return retryStreamOnPermissionDenied(
    () => taskRepository.watchTaskLogs(
      householdId,
      startDate: filter.startDate,
      endDate: filter.endDate,
      categoryId: filter.categoryId,
      performedBy: filter.performedBy,
      taskNameFr: filter.taskNameFr,
      difficulty: filter.difficulty,
    ),
  );
});

/// Provider for task controller
final taskControllerProvider =
    StateNotifierProvider<TaskController, AsyncValue<void>>((ref) {
  return TaskController(ref);
});

/// Controller for task operations
class TaskController extends StateNotifier<AsyncValue<void>> {
  TaskController(this.ref) : super(const AsyncValue.data(null));

  final Ref ref;

  /// Adds a new task log
  Future<void> addTask({
    required String householdId,
    required String taskName,
    required String taskNameFr,
    required String taskNameEn,
    required String categoryId,
    required int durationMinutes,
    required TaskDifficulty difficulty,
    DateTime? date,
    String? comment,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final taskRepository = ref.read(taskRepositoryProvider);
      final currentUser = await ref.read(currentUserProvider.future);

      if (currentUser == null) {
        throw Exception('User not authenticated');
      }

      final taskLog = TaskLog(
        id: '', // Will be generated by Firestore
        taskName: taskName,
        taskNameFr: taskNameFr,
        taskNameEn: taskNameEn,
        categoryId: categoryId,
        performedBy: currentUser.userId,
        performedByName: currentUser.displayName,
        date: date ?? DateTime.now(),
        durationMinutes: durationMinutes,
        difficulty: difficulty,
        comment: comment,
        createdAt: DateTime.now(),
      );

      await taskRepository.addTaskLog(householdId, taskLog);
    });
  }

  /// Updates an existing task log
  Future<void> updateTask({
    required String householdId,
    required TaskLog updatedLog,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final taskRepository = ref.read(taskRepositoryProvider);
      await taskRepository.updateTaskLog(householdId, updatedLog);
    });
  }

  /// Deletes a task log
  Future<void> deleteTask(String householdId, String logId) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final taskRepository = ref.read(taskRepositoryProvider);
      await taskRepository.deleteTaskLog(householdId, logId);
    });
  }
}
